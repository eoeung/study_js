// 참조

var a = {'id': 1};
var b = a;
b.id = 2;

console.log(a.id); // 2
// 변경한 것은 b의 id라는 property의 값이지만, a의 property인 id의 값도 변경되었음

// 원시 데이터 타입에서는 a에 담겨 있던 값을 하나 더 만들고, b가 참조했지만
// 객체 데이터 타입인 경우에는 그 객체를 새로 만들어진 변수가 똑같이 참조함

// 파일 1개를 복제해서, 2개의 파일이 되면, 아예 별도의 데이터가 된다. (하나의 파일을 수정해도 다른 복제 파일에 영향을 미치지 않음)
// symbolic link 또는 바로가기로 파일을 만들게 되면, 실제 데이터를 수정하는 경우에는 연결된 모든 파일의 값이 변한다.

console.log('----------------------------');

var a = {'id': 1};
var b = a; // a와 b는 똑같은 객체 {'id': 1}를 바라보고 있음
b = {'id': 2}; // 새로운 객체를 생성했음
// → b는 더 이상 {'id': 1}객체를 참조하지 않음
// → a와 b가 참조하는 값이 다름

console.log(a.id); // 1

// 아래 코드와 비슷한 원리이다.
var a = 1; // 1이라는 데이터를 만들어서 a에 할당
var b = a; // 1이 원시 데이터 타입이므로 1을 새로 복사해서 b에 할당
// → 위의 예제와는 다르게 a와 b가 똑같은 객체를 바라보는 것이 아니라 복제되어 b에 할당됨 (위의 예제는 객체 데이터 타입이고 지금 예제는 원시 데이터 타입이므로)
b = 2; // 2라는 데이터를 새로 만들어서 b에 할당
console.log(a); // 1